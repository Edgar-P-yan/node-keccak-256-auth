{"version":3,"file":"index.umd.min.js","sources":["../node_modules/axios/lib/core/buildFullPath.js","../node_modules/axios/lib/helpers/buildURL.js","../src/axios-interceptor.ts","../src/passport-strategy.ts","../src/axios-get-full-uri.ts"],"sourcesContent":["'use strict';\n\nvar isAbsoluteURL = require('../helpers/isAbsoluteURL');\nvar combineURLs = require('../helpers/combineURLs');\n\n/**\n * Creates a new URL by combining the baseURL with the requestedURL,\n * only when the requestedURL is not already an absolute URL.\n * If the requestURL is absolute, this function returns the requestedURL untouched.\n *\n * @param {string} baseURL The base URL\n * @param {string} requestedURL Absolute or relative URL to combine\n * @returns {string} The combined full path\n */\nmodule.exports = function buildFullPath(baseURL, requestedURL) {\n  if (baseURL && !isAbsoluteURL(requestedURL)) {\n    return combineURLs(baseURL, requestedURL);\n  }\n  return requestedURL;\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\nfunction encode(val) {\n  return encodeURIComponent(val).\n    replace(/%3A/gi, ':').\n    replace(/%24/g, '$').\n    replace(/%2C/gi, ',').\n    replace(/%20/g, '+').\n    replace(/%5B/gi, '[').\n    replace(/%5D/gi, ']');\n}\n\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @returns {string} The formatted url\n */\nmodule.exports = function buildURL(url, params, paramsSerializer) {\n  /*eslint no-param-reassign:0*/\n  if (!params) {\n    return url;\n  }\n\n  var serializedParams;\n  if (paramsSerializer) {\n    serializedParams = paramsSerializer(params);\n  } else if (utils.isURLSearchParams(params)) {\n    serializedParams = params.toString();\n  } else {\n    var parts = [];\n\n    utils.forEach(params, function serialize(val, key) {\n      if (val === null || typeof val === 'undefined') {\n        return;\n      }\n\n      if (utils.isArray(val)) {\n        key = key + '[]';\n      } else {\n        val = [val];\n      }\n\n      utils.forEach(val, function parseValue(v) {\n        if (utils.isDate(v)) {\n          v = v.toISOString();\n        } else if (utils.isObject(v)) {\n          v = JSON.stringify(v);\n        }\n        parts.push(encode(key) + '=' + encode(v));\n      });\n    });\n\n    serializedParams = parts.join('&');\n  }\n\n  if (serializedParams) {\n    var hashmarkIndex = url.indexOf('#');\n    if (hashmarkIndex !== -1) {\n      url = url.slice(0, hashmarkIndex);\n    }\n\n    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;\n  }\n\n  return url;\n};\n","import type { AxiosRequestConfig } from 'axios';\nimport * as ethUtil from 'ethereumjs-util';\nimport * as sigUtil from '@metamask/eth-sig-util';\nimport url from 'url';\nimport { axiosGetFullUri } from './axios-get-full-uri';\n\ntype AxiosInterceptor = (config: AxiosRequestConfig) => AxiosRequestConfig;\n\n/**\n * Adds Authorization header with the Keccak-256 schema to the requests.\n * @see https://coldstack.atlassian.net/wiki/spaces/CS/pages/322109441/HTTP\n */\nexport function keccak256AxiosInterceptor(params: {\n  privateKey: string;\n  signedHeaders?: string[];\n}): AxiosInterceptor {\n  const privateKey = Buffer.from(params.privateKey.replace(/^0x/, ''), 'hex');\n  const publicKey = ethUtil.privateToAddress(privateKey).toString('hex');\n  const defaultSignedHeaders = params.signedHeaders\n    ? params.signedHeaders.map((header) => header.toLowerCase())\n    : ['date', 'host'];\n\n  return function (config): AxiosRequestConfig {\n    if (!config.method) {\n      throw new TypeError(`config.method is ${config.method}`);\n    }\n\n    const uri = url.parse(axiosGetFullUri(config));\n\n    /** path is the \"/pathname?query=val\" part of the url */\n    const path = uri.path;\n\n    /**\n     * The list of headers\n     * @example\n     * [\"content-length:1024\", \"content-type:text/plain\"]\n     */\n    const headers: string[] = [];\n\n    // In the \"config\" object there is no Host header\n    // But it will appear only when the request sent.\n    // We set it here explicitly to make sure that\n    // in the signature the Host header will be included.\n    if (!hasKeyCaseInsensitive(config.headers, 'host')) {\n      const host = uri.host as string;\n      if (config.headers) {\n        config.headers['host'] = host;\n      } else {\n        config.headers = {\n          host,\n        };\n      }\n    }\n\n    if (!hasKeyCaseInsensitive(config.headers, 'date')) {\n      const date = new Date().toUTCString();\n      if (config.headers) {\n        config.headers['date'] = date;\n      } else {\n        config.headers = {\n          date,\n        };\n      }\n    }\n\n    // Delete all headers from SignedHeaders which are not specified in the configs\n    const signedHeaders = defaultSignedHeaders\n      .filter((header) => hasKeyCaseInsensitive(config.headers, header))\n      .sort();\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    Object.entries(config.headers!)\n      .map(([key, val]): [string, string] => [key.toLowerCase(), String(val)])\n      .filter(([key]) => signedHeaders.includes(key))\n      .sort(([key1], [key2]) => (key1 > key2 ? 1 : -1))\n      .forEach(([key, val]) => {\n        headers.push(`${key}:${val}`);\n      });\n\n    const stringToSign =\n      `${config.method.toUpperCase()} ${path}\\n` + headers.join('\\n');\n\n    const signature = sigUtil.personalSign({\n      privateKey,\n      data: ethUtil.bufferToHex(Buffer.from(stringToSign, 'utf-8')),\n    });\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    config.headers!['authorization'] =\n      'Keccak-256 public_key=' +\n      publicKey +\n      ',signed_headers=' +\n      signedHeaders.join(';') +\n      ',signature=' +\n      signature;\n\n    return config;\n  };\n}\n\nfunction hasKeyCaseInsensitive(\n  record: Record<string, unknown> | undefined,\n  key: string,\n): boolean {\n  const lowerKey = key.toLowerCase();\n  return record\n    ? Object.keys(record).some((k) => k.toLowerCase() === lowerKey)\n    : false;\n}\n","import type express from 'express';\nimport { Strategy } from 'passport-strategy';\nimport * as ethUtil from 'ethereumjs-util';\nimport * as sigUtil from '@metamask/eth-sig-util';\nimport type { Keccak256User } from './keccak-256-user.interface';\n\ninterface ParsedAuthorizationHeader {\n  publicKey: string;\n  signedHeaders: string[];\n  signature: string;\n}\n\ninterface AuthenticateOptions {\n  allowFrom: string[];\n}\n\nexport class Keccak256Strategy extends Strategy {\n  private options: AuthenticateOptions;\n\n  constructor(options: AuthenticateOptions) {\n    super();\n    this.options = options;\n  }\n\n  override authenticate(req: express.Request): void {\n    try {\n      const parsed = this.parseAuthorizationHeader(req);\n\n      if (\n        !this.options.allowFrom\n          .map((key) => key.toLowerCase())\n          .includes(parsed.publicKey.toLocaleLowerCase())\n      ) {\n        throw new Error('Unauthorized: unknown publicKey');\n      }\n\n      const stringToSign = this.getStringToSign(req, parsed);\n\n      const msgBufferHex = ethUtil.bufferToHex(\n        Buffer.from(stringToSign, 'utf8'),\n      );\n\n      const address = sigUtil.recoverPersonalSignature({\n        data: msgBufferHex,\n        signature: parsed.signature,\n      });\n\n      if (parsed.publicKey.toLowerCase() !== address.toLowerCase()) {\n        throw new Error('Unauthorized: wrong signature');\n      }\n\n      const user: Keccak256User = {\n        publicKey: parsed.publicKey,\n      };\n\n      this.success(user);\n    } catch (err) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      this.error(err as any);\n    }\n  }\n\n  private getStringToSign(\n    req: express.Request,\n    parsed: ParsedAuthorizationHeader,\n  ): string {\n    let stringToSign = `${req.method.toUpperCase()} ${req.originalUrl}\\n`;\n\n    if (parsed.signedHeaders.length) {\n      const headersEntries = Object.entries(req.headers)\n        .filter(([key]) => parsed.signedHeaders.includes(key))\n        .sort(([key1], [key2]) => (key1 > key2 ? 1 : -1))\n        .map((header) => {\n          // When the request has multiple headers with the same name sort\n          // them by their value\n          if (Array.isArray(header[1])) {\n            header[1] = header[1].sort();\n          }\n\n          return header;\n        });\n\n      const headersArr: string[] = [];\n\n      headersEntries.forEach((header) => {\n        if (!Array.isArray(header[1])) {\n          headersArr.push(header[0] + ':' + header[1]);\n        } else {\n          header[1].forEach((value) => {\n            headersArr.push(header[0] + ':' + value);\n          });\n        }\n      });\n\n      stringToSign += headersArr.join('\\n');\n    }\n\n    return stringToSign;\n  }\n\n  private parseAuthorizationHeader(\n    req: express.Request,\n  ): ParsedAuthorizationHeader {\n    if (\n      !req.headers.authorization ||\n      typeof req.headers.authorization !== 'string'\n    ) {\n      throw new Error('Missing Authorization header');\n    }\n\n    const [schema, params] = req.headers.authorization.split(' ') as [\n      string,\n      string,\n    ];\n    if (schema !== 'Keccak-256') {\n      throw new Error('Unknown authentication schema. Expected Keccak-256');\n    }\n\n    const [publicKeyPair, headersPartPair, signPartPair] = params\n      .split(',')\n      .map((pair) => pair.split('='));\n\n    if (\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      publicKeyPair![0] !== 'public_key' ||\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      headersPartPair![0] !== 'signed_headers' ||\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      signPartPair![0] !== 'signature'\n    ) {\n      throw new Error('Invalid Authentication header');\n    }\n\n    const result: ParsedAuthorizationHeader = {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      publicKey: publicKeyPair![1]!,\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      signedHeaders: headersPartPair![1]!\n        .split(';')\n        .filter((header) => !!header),\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      signature: signPartPair![1]!,\n    };\n\n    if (!result.publicKey.match(/^0x[a-fA-F0-9]{40}$/)) {\n      throw new Error('Invalid Authentication header');\n    }\n\n    return result;\n  }\n}\n","import type { AxiosRequestConfig } from 'axios';\nimport * as buildFullPath from 'axios/lib/core/buildFullPath';\nimport * as buildUrl from 'axios/lib/helpers/buildURL';\n\n/**\n * @see https://github.com/axios/axios/pull/3737\n */\nexport function axiosGetFullUri(config: AxiosRequestConfig): string {\n  // config = mergeConfig(this.defaults, config);\n  const fullPath = buildFullPath.default(config.baseURL, config.url);\n  return buildUrl.default(fullPath, config.params, config.paramsSerializer);\n}\n"],"names":["isAbsoluteURL","require","combineURLs","module","exports","baseURL","requestedURL","utils","encode","val","encodeURIComponent","replace","hasKeyCaseInsensitive","record","key","lowerKey","toLowerCase","Object","keys","some","k","url","params","paramsSerializer","serializedParams","isURLSearchParams","toString","parts","forEach","isArray","v","isDate","toISOString","isObject","JSON","stringify","push","join","hashmarkIndex","indexOf","slice","options","_super","_this","__extends","Keccak256Strategy","req","parsed","this","parseAuthorizationHeader","allowFrom","map","includes","publicKey","toLocaleLowerCase","Error","stringToSign","getStringToSign","msgBufferHex","ethUtil","bufferToHex","Buffer","from","address","sigUtil","recoverPersonalSignature","data","signature","user","success","err","error","method","toUpperCase","originalUrl","signedHeaders","length","headersEntries","entries","headers","filter","_a","sort","_b","header","Array","headersArr_1","value","authorization","split","schema","pair","publicKeyPair","headersPartPair","signPartPair","result","match","Strategy","privateKey","privateToAddress","defaultSignedHeaders","config","TypeError","uri","parse","buildUrl.default","buildFullPath.default","axiosGetFullUri","path","host","date","Date","toUTCString","String","personalSign"],"mappings":"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"}