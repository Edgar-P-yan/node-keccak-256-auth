{"version":3,"file":"index.umd.min.js","sources":["../src/axios-get-full-uri.ts","../src/axios-interceptor.ts","../src/passport-strategy.ts"],"sourcesContent":["import type { AxiosRequestConfig } from 'axios';\nimport axios from 'axios';\n\n/**\n * Gets full uri combining baseUrl and url.\n *\n * Axios does not export such method, so we implement it ourselves.\n * @see https://github.com/axios/axios/pull/3737\n */\nexport function axiosGetFullUri(config: AxiosRequestConfig): string {\n  const requestedURL = axios.getUri(config);\n\n  return buildFullPath(config.baseURL, requestedURL);\n}\n\n/**\n * Internal combineURLs helper function from axios\n * @see https://github.com/axios/axios/blob/d99d5faac29899eba68ce671e6b3cbc9832e9ad8/lib/helpers/combineURLs.js\n *\n * Creates a new URL by combining the specified URLs\n *\n * @param {string} baseURL The base URL\n * @param {string} relativeURL The relative URL\n * @returns {string} The combined URL\n */\nfunction combineURLs(baseURL: string, relativeURL: string): string {\n  return relativeURL\n    ? baseURL.replace(/\\/+$/, '') + '/' + relativeURL.replace(/^\\/+/, '')\n    : baseURL;\n}\n\n/**\n * Internal buildFullPath helper function from axios\n * @see https://github.com/axios/axios/blob/d99d5faac29899eba68ce671e6b3cbc9832e9ad8/lib/core/buildFullPath.js\n *\n * Creates a new URL by combining the baseURL with the requestedURL,\n * only when the requestedURL is not already an absolute URL.\n * If the requestURL is absolute, this function returns the requestedURL untouched.\n *\n * @param {string} baseURL The base URL\n * @param {string} requestedURL Absolute or relative URL to combine\n * @returns {string} The combined full path\n */\nfunction buildFullPath(baseURL: string | void, requestedURL: string): string {\n  if (baseURL && !isAbsoluteURL(requestedURL)) {\n    return combineURLs(baseURL, requestedURL);\n  }\n  return requestedURL;\n}\n\n/**\n * Internal isAbsoluteURL helper function from axios\n * @see https://github.com/axios/axios/blob/d99d5faac29899eba68ce671e6b3cbc9832e9ad8/lib/helpers/isAbsoluteURL.js\n *\n * Determines whether the specified URL is absolute\n *\n * @param {string} url The URL to test\n * @returns {boolean} True if the specified URL is absolute, otherwise false\n */\nfunction isAbsoluteURL(url: string): boolean {\n  // A URL is considered absolute if it begins with \"<scheme>://\" or \"//\" (protocol-relative URL).\n  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n  // by any combination of letters, digits, plus, period, or hyphen.\n  return /^([a-z][a-z\\d+\\-.]*:)?\\/\\//i.test(url);\n}\n","import type { AxiosRequestConfig } from 'axios';\nimport * as ethUtil from 'ethereumjs-util';\nimport * as sigUtil from '@metamask/eth-sig-util';\nimport url from 'url';\nimport { axiosGetFullUri } from './axios-get-full-uri';\nimport _debug from 'debug';\nconst debug = _debug('keccak-256-auth:axios-interceptor');\n\ntype AxiosInterceptor = (config: AxiosRequestConfig) => AxiosRequestConfig;\n\n/**\n * Adds Authorization header with the Keccak-256 schema to the requests.\n * @see https://coldstack.atlassian.net/wiki/spaces/CS/pages/322109441/HTTP\n */\nexport function keccak256AxiosInterceptor(params: {\n  privateKey: string;\n  signedHeaders?: string[];\n  debug?: boolean;\n}): AxiosInterceptor {\n  const privateKey = Buffer.from(params.privateKey.replace(/^0x/, ''), 'hex');\n  const publicKey = ethUtil.bufferToHex(ethUtil.privateToAddress(privateKey));\n  const defaultSignedHeaders = params.signedHeaders\n    ? params.signedHeaders.map((header) => header.toLowerCase())\n    : ['date', 'host'];\n\n  params.debug &&\n    debug(\n      `Initialized: publicKey=${publicKey}, signedHeaders=${defaultSignedHeaders.join(\n        ';',\n      )}`,\n    );\n\n  return function _keccak256AxiosInterceptor(\n    config: AxiosRequestConfig,\n  ): AxiosRequestConfig {\n    if (!config.method) {\n      throw new TypeError(`config.method is ${config.method}`);\n    }\n\n    const uri = url.parse(axiosGetFullUri(config));\n\n    /** path is the \"/pathname?query=val\" part of the url */\n    const path = uri.path;\n\n    /**\n     * The list of headers\n     * @example\n     * [\"content-length:1024\", \"content-type:text/plain\"]\n     */\n    const headers: string[] = [];\n\n    // In the \"config\" object there is no Host header\n    // But it will appear only when the request sent.\n    // We set it here explicitly to make sure that\n    // in the signature the Host header will be included.\n    if (!hasKeyCaseInsensitive(config.headers, 'host')) {\n      const host = uri.host as string;\n      if (config.headers) {\n        config.headers['host'] = host;\n      } else {\n        config.headers = {\n          host,\n        };\n      }\n    }\n\n    if (!hasKeyCaseInsensitive(config.headers, 'date')) {\n      const date = new Date().toUTCString();\n      if (config.headers) {\n        config.headers['date'] = date;\n      } else {\n        config.headers = {\n          date,\n        };\n      }\n    }\n\n    // Delete all headers from SignedHeaders which are not specified in the configs\n    const signedHeaders = defaultSignedHeaders\n      .filter((header) => hasKeyCaseInsensitive(config.headers, header))\n      .sort();\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    Object.entries(config.headers!)\n      .map(([key, val]): [string, string] => [key.toLowerCase(), String(val)])\n      .filter(([key]) => signedHeaders.includes(key))\n      .sort(([key1], [key2]) => (key1 > key2 ? 1 : -1))\n      .forEach(([key, val]) => {\n        headers.push(`${key}:${val}`);\n      });\n\n    const stringToSign =\n      `${config.method.toUpperCase()} ${path}\\n` + headers.join('\\n');\n\n    const signature = sigUtil.personalSign({\n      privateKey,\n      data: ethUtil.bufferToHex(Buffer.from(stringToSign, 'utf-8')),\n    });\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    config.headers!['authorization'] =\n      'Keccak-256 public_key=' +\n      publicKey +\n      ',signed_headers=' +\n      signedHeaders.join(';') +\n      ',signature=' +\n      signature;\n\n    if (params.debug) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      config.headers!['x-keccak-256-string-to-sign'] = stringToSign;\n    }\n\n    debug(`String to sign: ${stringToSign}`);\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    debug(`Authorization header: ${config.headers!['authorization']}`);\n\n    return config;\n  };\n}\n\nfunction hasKeyCaseInsensitive(\n  record: Record<string, unknown> | undefined,\n  key: string,\n): boolean {\n  const lowerKey = key.toLowerCase();\n  return record\n    ? Object.keys(record).some((k) => k.toLowerCase() === lowerKey)\n    : false;\n}\n","import type express from 'express';\nimport { Strategy } from 'passport-strategy';\nimport * as ethUtil from 'ethereumjs-util';\nimport * as sigUtil from '@metamask/eth-sig-util';\nimport type { Keccak256User } from './keccak-256-user.interface';\n\ninterface ParsedAuthorizationHeader {\n  publicKey: string;\n  signedHeaders: string[];\n  signature: string;\n}\n\nexport class Keccak256Strategy extends Strategy {\n  override authenticate(req: express.Request): void {\n    try {\n      const parsed = this.parseAuthorizationHeader(req);\n\n      const stringToSign = this.getStringToSign(req, parsed);\n\n      const msgBufferHex = ethUtil.bufferToHex(\n        Buffer.from(stringToSign, 'utf8'),\n      );\n\n      const address = sigUtil.recoverPersonalSignature({\n        data: msgBufferHex,\n        signature: parsed.signature,\n      });\n\n      if (parsed.publicKey.toLowerCase() !== address.toLowerCase()) {\n        throw new Error('Unauthorized: wrong signature');\n      }\n\n      const user: Keccak256User = {\n        publicKey: parsed.publicKey,\n      };\n\n      this.success(user);\n    } catch (err) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      this.error(err as any);\n    }\n  }\n\n  private getStringToSign(\n    req: express.Request,\n    parsed: ParsedAuthorizationHeader,\n  ): string {\n    let stringToSign = `${req.method.toUpperCase()} ${req.originalUrl}\\n`;\n\n    if (parsed.signedHeaders.length) {\n      const headersEntries = Object.entries(req.headers)\n        .filter(([key]) => parsed.signedHeaders.includes(key))\n        .sort(([key1], [key2]) => (key1 > key2 ? 1 : -1))\n        .map((header) => {\n          // When the request has multiple headers with the same name sort\n          // them by their value\n          if (Array.isArray(header[1])) {\n            header[1] = header[1].sort();\n          }\n\n          return header;\n        });\n\n      const headersArr: string[] = [];\n\n      headersEntries.forEach((header) => {\n        if (!Array.isArray(header[1])) {\n          headersArr.push(header[0] + ':' + header[1]);\n        } else {\n          header[1].forEach((value) => {\n            headersArr.push(header[0] + ':' + value);\n          });\n        }\n      });\n\n      stringToSign += headersArr.join('\\n');\n    }\n\n    return stringToSign;\n  }\n\n  private parseAuthorizationHeader(\n    req: express.Request,\n  ): ParsedAuthorizationHeader {\n    if (\n      !req.headers.authorization ||\n      typeof req.headers.authorization !== 'string'\n    ) {\n      throw new Error('Missing Authorization header');\n    }\n\n    const [schema, params] = req.headers.authorization.split(' ') as [\n      string,\n      string,\n    ];\n    if (schema !== 'Keccak-256') {\n      throw new Error('Unknown authentication schema. Expected Keccak-256');\n    }\n\n    const [publicKeyPair, headersPartPair, signPartPair] = params\n      .split(',')\n      .map((pair) => pair.split('='));\n\n    if (\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      publicKeyPair![0] !== 'public_key' ||\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      headersPartPair![0] !== 'signed_headers' ||\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      signPartPair![0] !== 'signature'\n    ) {\n      throw new Error('Invalid Authentication header');\n    }\n\n    const result: ParsedAuthorizationHeader = {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      publicKey: publicKeyPair![1]!,\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      signedHeaders: headersPartPair![1]!\n        .split(';')\n        .filter((header) => !!header),\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      signature: signPartPair![1]!,\n    };\n\n    if (!result.publicKey.match(/^0x[a-fA-F0-9]{40}$/)) {\n      throw new Error('Invalid Authentication header');\n    }\n\n    return result;\n  }\n}\n"],"names":["axiosGetFullUri","config","requestedURL","axios","getUri","baseURL","url","test","isAbsoluteURL","relativeURL","replace","combineURLs","buildFullPath","debug","hasKeyCaseInsensitive","record","key","lowerKey","toLowerCase","Object","keys","some","k","__extends","Keccak256Strategy","req","parsed","this","parseAuthorizationHeader","stringToSign","getStringToSign","msgBufferHex","ethUtil","bufferToHex","Buffer","from","address","sigUtil","recoverPersonalSignature","data","signature","publicKey","Error","user","success","err","error","method","toUpperCase","originalUrl","signedHeaders","length","headersEntries","entries","headers","filter","_a","includes","sort","_b","map","header","Array","isArray","headersArr_1","forEach","value","push","join","authorization","split","schema","params","pair","publicKeyPair","headersPartPair","signPartPair","result","match","Strategy","privateKey","privateToAddress","defaultSignedHeaders","TypeError","uri","parse","path","host","date","Date","toUTCString","val","String","personalSign"],"mappings":"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"}